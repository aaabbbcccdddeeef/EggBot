Uses "UI"
Uses "CONSOLE"
Uses "COMM"
Uses "WMI"
Uses "OS"
Uses "File"

'---Constant declarations
Begin ControlID
  %ID_StartUpdateButton
  %ID_ExitButton
  %ID_CommandOutputTexBox
  %ID_ManualButton
  %ID_HEXSelectFrame
  %ID_HEXSelectLabel
  %ID_HEXSelectButton
  %ID_HEXSelectTextBox
  %ID_HEXDefaultTextBox
  %ID_HEXSelectAutoOption
  %ID_HEXSelectManualOption
  %ID_COMSelectFrame
  %ID_COMSelectButton
  %ID_COMSelectTextBox
  %ID_COMSelectAutoOption
  %ID_COMSelectManualOption
  %ID_COMSelectNoneOption
  %IDC_TIMER
End ControlID

%TIMER_DELAY    = 100          '---Timer delay (in milliseconds, not very accurate below about 100)

Global hComm                As Long
Global nBytes               As Long
Global sBuffer              As String
Global gPortOpen            As Boolean
Global vData()              As String
Global nItems               As Long
Global Counter              As Long
Global Position             As Long
Global ComputerName         As String   Value OS_GetComputerName
Global Ports()              As String
Global CountATI             As Long
Global sHexFilename         As String
Global sFirmwareNumber      As String
Global bConsole             As Boolean
Global bUpdaterConsole      As Boolean
Global sCommandLine         As String
Global bAdvancedModeActive  as boolean  value false
global sDefaultHexFileName as string

' Replace the filename in the next three lines to change which HEX file gets programmed
sDefaultHexFilename = "EBF_v280.hex"
#BUNDLE File "HEX", ".\EBF_v280.hex", "", ReplaceExisting=1
sFirmwareNumber = "2.8.0"

bConsole = TRUE  ' for normal printfs
bUpdaterConsole = TRUE ' for mphidflash
sHexFilename = "EBF_v" & Replace$(sFirmwareNumber, ".", "") & ".hex"
#BUNDLE File "app", ".\mphidflash-1.6-win-32.exe", "", ReplaceExisting=1
#BUNDLE Icon "WhiteEBBv20.ico"

'------------------------------------------------------------------------------
' Program start point
'------------------------------------------------------------------------------
Function TBMain() As Long
  Local hDlg    As DWord   '---Used to store window handle of main dialog

  gPortOpen = FALSE
  '---Create a new dialog
  hDlg = Dialog_New Pixels, 0, "EBB Update to firmware v" & sFirmwareNumber, -1, -1, 400, 390,
                                                %WS_DLGFRAME  | 
                                                %DS_CENTER    | 
                                                %WS_CAPTION   | 
                                                %WS_SYSMENU   | 
                                                %WS_OVERLAPPEDWINDOW

  '---Set window minimum size
  Dialog Set Minsize hDlg, 400, 390

  '---Show dialog in modal mode
  '---cbDialog function is the callback function handling dialog events
  '---Application control will pass to dialog callback till dialog will exists 
  Dialog Show Modal hDlg, Call cbDialog

  '---If execution comes here it means main dialog as been destroyed
  If (bConsole) Then Console_WriteLine "---Application finished ---"
  
End Function 

'------------------------------------------------------------------------------
' Callback procedure for main window
'------------------------------------------------------------------------------
CallBack Function cbDialog() As Long

  'If (bConsole) Then Console_Writeline CBHNDL, CBCTL, CBCTLMSG, CBLPARAM, CBWPARAM
  
  Select Case CBMSG
    
    Case %WM_CREATE
      If (bConsole) Then Console_WriteLine Time$, "Fired %WM_CREATE dialog message"

    Case %WM_INITDIALOG
      If (bConsole) Then Console_WriteLine Time$, "Fired %WM_INITDIALOG dialog message"
      '---Add controls
      Control Add Button   CBHNDL, %ID_StartUpdateButton, "Start Update",           160,  10,  80,  25, %BS_NOTIFY | %WS_TABSTOP Call cbButton
      Control Add Button   CBHNDL, %ID_ExitButton, "Exit",                          160, 350,  80,  25, %BS_NOTIFY | %WS_TABSTOP Call cbButton
      control add button   Cbhndl, %ID_ManualButton, "Advanced",                    300, 350,  80,  25, %BS_NOTIFY | %WS_TABSTOP Call cbButton
      Control Add Textbox  CBHNDL, %ID_CommandOutputTexBox, "",                      10,  40, 380, 300, %ES_MULTILINE | %ES_AUTOVSCROLL | %WS_HSCROLL | %ES_AUTOHSCROLL | %WS_VSCROLL | %ES_READONLY

      control add frame    Cbhndl, %ID_HEXSelectFrame, "HEX file selection",         10, 380, 375,  75
      control add Textbox  Cbhndl, %ID_HEXDefaultTextBox, "",                        20, 425,  80,  20, %ES_READONLY
      control add Option   Cbhndl, %ID_HEXSelectAutoOption, "Default",               20, 400,  50,  20, %WS_GROUP OR %WS_TABSTOP
      control add option   Cbhndl, %ID_HEXSelectManualOption, "Custom",             105, 400,  60,  20
      CONTROL SET OPTION   Cbhndl, %ID_HEXSelectAutoOption, %ID_HEXSelectAutoOption, %ID_HEXSelectManualOption
      Control Add Button   Cbhndl, %ID_HEXSelectButton,"...",                       175, 395,  30,  25, %BS_NOTIFY | %WS_TABSTOP Call cbButton
      Control Add Textbox  CBHNDL, %ID_HEXSelectTextBox, "",                        105, 425, 275,  20
      control set text     Cbhndl, %ID_HEXDefaultTextBox, sDefaultHexFilename

      Control Show State   Cbhndl, %ID_HEXSelectFrame, %SW_HIDE
      Control Show State   Cbhndl, %ID_HEXSelectAutoOption, %SW_HIDE
      Control Show State   Cbhndl, %ID_HEXDefaultTextBox, %SW_HIDE
      Control Show State   Cbhndl, %ID_HEXSelectManualOption, %SW_HIDE
      Control Show State   Cbhndl, %ID_HEXSelectButton, %SW_HIDE
      Control Show State   Cbhndl, %ID_HEXSelectTextBox, %SW_HIDE

      Control add frame    Cbhndl, %ID_COMSelectFrame, "COM port selection (e.g. COM12)",10, 460, 375,  45
      control add Option   Cbhndl, %ID_COMSelectAutoOption, "Auto",                  20, 480,  60,  20, %WS_GROUP OR %WS_TABSTOP
      control add option   Cbhndl, %ID_COMSelectManualOption, "Manual",             105, 480,  55,  20
      control add option   Cbhndl, %ID_COMSelectNoneOption, "Direct Bootloader",    260, 480, 200,  20
      CONTROL SET OPTION   Cbhndl, %ID_COMSelectAutoOption, %ID_COMSelectAutoOption, %ID_COMSelectNoneOption
      Control Add Textbox  CBHNDL, %ID_COMSelectTextBox, "",                        170, 480,  60,  20

      Control Show State   Cbhndl, %ID_COMSelectFrame, %SW_HIDE
      Control Show State   Cbhndl, %ID_COMSelectAutoOption, %SW_HIDE
      Control Show State   Cbhndl, %ID_COMSelectManualOption, %SW_HIDE
      Control Show State   Cbhndl, %ID_COMSelectTextBox, %SW_HIDE
      Control Show State   Cbhndl, %ID_COMSelectNoneOption, %SW_HIDE

    Case %WM_COMMAND
      'If (bConsole) Then Console_Writeline Time$, "Fired %WM_COMMAND dialog message", CBCTL
 
    Case %WM_SIZE     '---The WM_SIZE message is sent to a window after its size has changed.
      'If (bConsole) Then Console_Writeline Time$, "Fired %WM_SIZE dialog message", CBWPARAM, LOWRD(CBLPARAM), HIWRD(CBLPARAM)

    Case %WM_SIZING   '---The WM_SIZING message is sent to a window that the user is resizing.
      'If (bConsole) Then Console_Writeline Time$, "Fired %WM_SIZING dialog message", CBWPARAM, LOWRD(CBLPARAM), HIWRD(CBLPARAM)

    Case %WM_MOVE
      'If (bConsole) Then Console_Writeline Time$, "Fired %WM_MOVE dialog message", LO(Integer, CBLPARAM), HI(Integer, CBLPARAM)
      
    Case %WM_DESTROY
      '---Do whatever needed just before dialog is destroyed.
      If gPortOpen = TRUE Then
        gPortOpen = FALSE
        COMM_Close(hComm)
      End If
      'If (bConsole) Then Console_Writeline Time$, "Fired %WM_DESTROY dialog message"

    Case %WM_TIMER
    
      Select Case CBWPARAM
        Case %IDC_TIMER
''          If gPortOpen = TRUE Then
''            nBytes = COMM_Get(hComm, %COMM_RXQUE)
''            COMM_Recv(hComm, nBytes, sBuffer)
''            add_new_bytes(sBuffer, CBHNDL)
''          EndIf
        End Select

  End Select

End Function

function PerformUpdate() as long
  local pID As Number

  sCommandLine = DIR_GetCurrent + "\mphidflash-1.6-win-32.exe -r -w " & sHexFilename
  If (bConsole) Then Console_WriteLine sCommandLine
  If (bUpdaterConsole) Then
    pID = OS_Shell(sCommandLine, %OS_WNDSTYLE_NORMAL, %OS_SHELL_SYNC)
  Else
    pID = OS_Shell(sCommandLine, %OS_WNDSTYLE_HIDE, %OS_SHELL_SYNC)
  EndIf

  Sleep 2000
  
  If (bConsole) Then
    Console_WriteLine("pID = " & pID)
  endif
  
  return pID
end function

function FlashEBBFromComPort(hndl as long, comPort as String)
  dim lHEXAutoOption as long

  if comPort <> "" then
    hComm = COMM_FreeFile
    Control Append Text hndl, %ID_CommandOutputTexBox, "Testing port " & comPort & " ... "
    COMM_Open("\\.\" & comPort, hComm)
    If Err = 0 Then
      COMM_Set(hComm, %COMM_BAUD, 123)
      COMM_Print(hComm, "V" & Chr$(13))
      Sleep 100
      nBytes = COMM_Get(hComm, %COMM_RXQUE)
      COMM_TRecv(hComm, nBytes, sBuffer, 1000)
      
      COMM_Print(hComm, "V" & Chr$(13))
      Sleep 100
      nBytes = COMM_Get(hComm, %COMM_RXQUE)
      COMM_TRecv(hComm, nBytes, sBuffer, 1000)
      
      sBuffer = Trim$(sbuffer, Any Chr$(13) & Chr$(10))
      If LEFT$(sBuffer, 3) = "EBB" Then
        Control Append Text hndl, %ID_CommandOutputTexBox, "Found an EBB with firmware version " & RIGHT$(sBuffer, 5) + Chr$(13) + Chr$(10)

        control get check hndl, %ID_HEXSelectAutoOption to lHEXAutoOption

        if bAdvancedModeActive = true and lHEXAutoOption = 0 then
          control Get text hndl, %ID_HEXSelectTextBox to sHexFilename
          Control Append Text hndl, %ID_CommandOutputTexBox, "Attempting update to hex file '" & sHexFilename & "'" + Chr$(13) + Chr$(10)
        else
          Control Append Text hndl, %ID_CommandOutputTexBox, "Attempting update to version " & sFirmwareNumber + Chr$(13) + Chr$(10)
        endif

        COMM_Print(hComm, "BL" & Chr$(13))
        Sleep 100
        COMM_Close(hComm)
        Sleep 2000
        
        If PerformUpdate() = 0 Then
          COMM_Open("\\.\" & comPort, hComm)
          If Err = 0 Then
            COMM_Print(hComm, "V" & Chr$(13))
            Sleep 200
            nBytes = COMM_Get(hComm, %COMM_RXQUE)
            COMM_TRecv(hComm, nBytes, sBuffer, 1000)
            Sleep 200
            COMM_Print(hComm, "V" & Chr$(13))
            Sleep 200
            nBytes = COMM_Get(hComm, %COMM_RXQUE)
            COMM_TRecv(hComm, nBytes, sBuffer, 1000)
            sBuffer = Trim$(sbuffer, Any Chr$(13) & Chr$(10))
            if bAdvancedModeActive = false then
              If (RIGHT$(sBuffer,5) = sFirmwareNumber) Then
                Control Append Text hndl, %ID_CommandOutputTexBox, "Updated to version " & RIGHT$(sBuffer,5) & " successfully" + Chr$(13) + Chr$(10)
              Else
                Control Append Text hndl, %ID_CommandOutputTexBox, "Incorrect version detected. EBB= " & RIGHT$(sBuffer,5) & " File= " & sFirmwareNumber & " Updated failed." + Chr$(13) + Chr$(10)
              endif
            else
              Control Append Text hndl, %ID_CommandOutputTexBox, "Updated to version " & RIGHT$(sBuffer,5) & " successfully" + Chr$(13) + Chr$(10)
            EndIf
            COMM_Close(hComm)
          else
              Control Append Text hndl, %ID_CommandOutputTexBox, "Failed to open COM port after update" + Chr$(13) + Chr$(10)
          EndIf
        Else
          Control Append Text hndl, %ID_CommandOutputTexBox, "Programming EBB failed with an error." + Chr$(13) + Chr$(10)
        EndIf
      Else
        Control Append Text hndl, %ID_CommandOutputTexBox, " no EBB found" + Chr$(13) + Chr$(10)
        'If (bConsole) Then Console_WriteLine("...closing port " & "\\.\" & Ports(Counter))
        COMM_Close(hComm)
      EndIf
    Else
      Control Append Text hndl, %ID_CommandOutputTexBox, "Error: " & Err + Chr$(13) + Chr$(10)
    End If
  else
    Control Append Text hndl, %ID_CommandOutputTexBox, "Attempting to program EBB directly in bootloader mode." + Chr$(13) + Chr$(10)
    If PerformUpdate() = 0 Then
      Control Append Text hndl, %ID_CommandOutputTexBox, "Successfully programmed EBB in bootloader mode." + Chr$(13) + Chr$(10)
    else
      Control Append Text hndl, %ID_CommandOutputTexBox, "Programming EBB failed with an error." + Chr$(13) + Chr$(10)
    EndIf
  endif
end function

'------------------------------------------------------------------------------
' Callback procedure for button control
'------------------------------------------------------------------------------
CallBack Function cbButton() As Long
  Local sComPort As String
  Local sTemp As String
  Local dFloat As Double
  local lCOMAutoOption as long
  local lCOMManualOption as long
  local lHEXAutoOption as long
  local sHexFilename as string

  If CBMSG = %WM_COMMAND Then

    Select Case CBCTLMSG
      Case %BN_CLICKED
        Select Case CBCTL

          Case %ID_StartUpdateButton
          
            control get check CBHNDL, %ID_COMSelectAutoOption to lCOMAutoOption
            control get check CBHNDL, %ID_COMSelectManualOption to lCOMManualOption
            control get check CBHNDL, %ID_HEXSelectAutoOption to lHEXAutoOption

            control Get text CBHNDL, %ID_HEXSelectTextBox to sHexFilename
            if bAdvancedModeActive = true and lHEXAutoOption = 0 and len(sHexFilename) < 4 then
                Control Append Text CBHNDL, %ID_CommandOutputTexBox, "Need valid HEX file and path to program." + Chr$(13) + Chr$(10)
            else

              if bAdvancedModeActive = False or (bAdvancedModeActive = true and lCOMAutoOption = 1) then
                Control Append Text CBHNDL, %ID_CommandOutputTexBox, "Building a list of COM ports ..." + Chr$(13) + Chr$(10)
                sBuffer = WMI_GetData(ComputerName, "", "", "", "Win32_PnPEntity", "", "Name" )
                  
                nItems = Parse( sBuffer, vData(), $CRLF)
                
                ReDim Ports()
                  
                For Counter = 1 To nItems
                  Position = InStr(Ucase$(vData(Counter)),"(COM")
                  If Position Then
                    ReDim Preserve Ports(UBound(Ports)+1)
                    PortS(UBound(Ports)) = Extract$(Position+1,vData(Counter),")")
                  End If
                Next

                ' Check for no COM ports found
                If LBound(Ports) = 1 And UBound(Ports) = 1 Then
                  Control Append Text CBHNDL, %ID_CommandOutputTexBox, "No COM ports found on this computer. Click Exit." + Chr$(13) + Chr$(10)
                Else
                  Control Append Text CBHNDL, %ID_CommandOutputTexBox, "Found the following ports:" + Chr$(13) + Chr$(10)
                  For Counter = LBound(Ports) To UBound(Ports)
                    if left$(Ports(Counter), 3) = "COM" then
                      Control Append Text CBHNDL, %ID_CommandOutputTexBox, Ports(Counter) + Chr$(13) + Chr$(10)
                    endif
                  Next
                  For Counter = LBound(Ports) To UBound(Ports)
                    if left$(Ports(Counter), 3) = "COM" then
                      FlashEBBFromComPort(Cbhndl, Ports(Counter))
                    endif
                  Next
                  Control Append Text CBHNDL, %ID_CommandOutputTexBox, "Click Exit (or click Start Upgrade again to update more EBBs)" + Chr$(13) + Chr$(10)
                EndIf
              else
                if lCOMManualOption = true then
                  control get text Cbhndl, %ID_COMSelectTextBox to sComPort

                  if left$(sComPort, 3) = "COM" then
                    FlashEBBFromComPort(Cbhndl, sComPort)
                  else
                    Control Append Text CBHNDL, %ID_CommandOutputTexBox, "Value in 'COM port' field manual text field '" + sComPort + "' is not a valid COM port." + Chr$(13) + Chr$(10)
                  endif
                else
                  ' We know we are in advaced mode and that the COM 'None' is selected
                  ' Use empty com port string to signal that we don't want to use com ports (i.e. already in bootlaoder mode)
                  FlashEBBFromComPort(Cbhndl, "")
                endif
              endif
            endif
            
''          Case %ID_OpenCommButton
''            If (bConsole) Then Console_Writeline Time$, "OpenCommButton clicked" 
''            Control Get Text CBHNDL, %ID_ComPortTextBox To sComPort
''            If (bConsole) Then Console_WriteLine("Opening COM" & sComPort)
''            hComm = COMM_FreeFile
''            COMM_Open("\\.\COM" & sComPort, hComm)
  
''            If Err = 0 Then
''              COMM_Set(hComm, %COMM_BAUD, 921600)
''              COMM_Set(hComm, %COMM_BYTE, 8)
''              COMM_Set(hComm, %COMM_PARITY, FALSE)
''              COMM_Set(hComm, %COMM_STOP, 0)
''              If (bConsole) Then Console_WriteLine("...open ok.")
''              gPortOpen = TRUE
''              Dialog Set Timer CBHNDL, %IDC_TIMER, %TIMER_DELAY 
''              write_to_com("debug level all", CBHNDL)
''            Else
''              If (bConsole) Then Console_WriteLine("Error: " & Err)
''            End If

          case %ID_ManualButton
            if bAdvancedModeActive = true then
              Dialog Set Size Cbhndl, 400, 390

              Control Show State   Cbhndl, %ID_HEXSelectFrame, %SW_HIDE
              Control Show State   Cbhndl, %ID_HEXSelectAutoOption, %SW_HIDE
              Control Show State   Cbhndl, %ID_HEXDefaultTextBox, %SW_HIDE
              Control Show State   Cbhndl, %ID_HEXSelectManualOption, %SW_HIDE
              Control Show State   Cbhndl, %ID_HEXSelectButton, %SW_HIDE
              Control Show State   Cbhndl, %ID_HEXSelectTextBox, %SW_HIDE

              Control Show State   Cbhndl, %ID_COMSelectFrame, %SW_HIDE
              Control Show State   Cbhndl, %ID_COMSelectAutoOption, %SW_HIDE
              Control Show State   Cbhndl, %ID_COMSelectManualOption, %SW_HIDE
              Control Show State   Cbhndl, %ID_COMSelectTextBox, %SW_HIDE
              Control Show State   Cbhndl, %ID_COMSelectNoneOption, %SW_HIDE
              
              control set text     Cbhndl, %ID_ManualButton, "Advanced"

              bAdvancedModeActive = false
            else
              Dialog Set Size Cbhndl, 400, 550

              Control Show State   Cbhndl, %ID_HEXSelectFrame, %SW_SHOW
              Control Show State   Cbhndl, %ID_HEXSelectAutoOption, %SW_SHOW
              Control Show State   Cbhndl, %ID_HEXDefaultTextBox, %SW_SHOW
              Control Show State   Cbhndl, %ID_HEXSelectManualOption, %SW_SHOW
              Control Show State   Cbhndl, %ID_HEXSelectButton, %SW_SHOW
              Control Show State   Cbhndl, %ID_HEXSelectTextBox, %SW_SHOW

              Control Show State   Cbhndl, %ID_COMSelectFrame, %SW_SHOW
              Control Show State   Cbhndl, %ID_COMSelectAutoOption, %SW_SHOW
              Control Show State   Cbhndl, %ID_COMSelectManualOption, %SW_SHOW
              Control Show State   Cbhndl, %ID_COMSelectTextBox, %SW_SHOW
              Control Show State   Cbhndl, %ID_COMSelectNoneOption, %SW_SHOW

              control set text     Cbhndl, %ID_ManualButton, "Auto"
              
              bAdvancedModeActive = true
            endif

          case %ID_HEXSelectButton
            if bAdvancedModeActive = True then
              sHexFilename = Dialog_OpenFile(Cbhndl, "Choose an EBB firmware HEX file to program", DIR_GetCurrent, "HEX files (*.HEX)|*.HEX|", "HEX", )
              control set text Cbhndl, %ID_HEXSelectTextBox, sHexFilename
            endif

          Case %ID_ExitButton
            If (bConsole) Then Console_WriteLine Time$, "CloseCommButton"
            If gPortOpen = TRUE Then
              gPortOpen = FALSE
              COMM_Close(hComm)
            End If
            If (bConsole) Then Console_WriteLine("port closed")
            Dialog End CBHNDL
            
        End Select
    End Select

    '---If button callback does not return %TRUE, message is passed
    '---to parent window
    Function = %TRUE

  End If
End Function

' Take new string from com port, look for CR/LF
' Then handle the line based on first character
Function add_new_bytes(sNewBytes As String, hndl As Long)
   Local x     As Long
   
   For x = 1 To Len(sNewBytes)
     sCurrentLine = sCurrentLine + Mid$(sNewBytes, x, 1)
     If RIGHT$(sCurrentLine, 1) = Chr$(13) Then
      ' We have a new line 
      If LEFT$(sCurrentLine, 1) = "~" Then
        handle_PI_line(sCurrentLine, hndl)
      Else
        handle_normal_line(sCurrentLine, hndl)
      End If
      sCurrentLine = ""
     End If
   Next x
End Function



' We need to write slowly so that we don't over-run the handle's one-byte buffer
Function write_to_com(sLine As String, hndl As Long)
  Local StartTime As Long
  Local x As Long

  sLine = sLine + Chr$(13)
  
  For x = 1 To Len(sLine)
    StartTime = GetTickCount
    While (StartTime + 10) > GetTickCount
    Wend
    COMM_Send(hComm, Mid$(sLine, x, 1))
  Next x

  Control Append Text hndl, %ID_CommandOutputTexBox, sLine + Chr$(10)

  If (bConsole) Then Write sLine + Chr$(10)
End Function
 